<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mapa Interativo de Exoplanetas — Stellar Worlds</title>
<style>
  :root{
    --bg:#070707;
    --gold:#f7c948;
    --muted:#9a9a9a;
    --panel-bg: rgba(5,5,5,0.95);
  }
  html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;}
  .wrap{display:flex;height:100vh;width:100vw;align-items:stretch;}
  /* Canvas container */
  #visual{
    position:relative;
    flex:1;
    overflow:hidden;
    background: radial-gradient(ellipse at center, rgba(255,220,170,0.02) 0%, rgba(0,0,0,0.6) 55%, rgba(0,0,0,1) 100%);
  }
  canvas{display:block; width:100%; height:100%;}
  /* Tooltip */
  .tooltip{
    position:absolute;
    pointer-events:none;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.6));
    color:var(--gold);
    padding:8px 10px;
    border-radius:6px;
    border:1px solid rgba(255,200,80,0.08);
    font-size:13px;
    transform:translate(-50%,-120%);
    white-space:nowrap;
    box-shadow:0 6px 18px rgba(0,0,0,0.6);
    backdrop-filter: blur(6px);
    display:none;
  }
  /* Side panel for details */
  .side-panel{
    width:360px;
    max-width:40%;
    background:var(--panel-bg);
    color:#fff;
    border-left:1px solid rgba(255,255,255,0.03);
    padding:20px;
    box-sizing:border-box;
    transition:transform .35s cubic-bezier(.2,.9,.2,1);
    transform:translateX(100%);
    position:relative;
  }
  .side-panel.open{transform:translateX(0);}
  .side-panel h2{margin:0 0 8px 0;color:var(--gold);font-size:20px;}
  .meta{color:var(--muted);font-size:13px;margin-bottom:14px;}
  .kv{display:flex;justify-content:space-between;padding:8px 0;border-bottom:1px dashed rgba(255,255,255,0.03);}
  .closeBtn{position:absolute;top:10px;right:10px;background:none;border:0;color:var(--muted);cursor:pointer;font-size:18px}
  /* Minimal controls */
  .controls{position:absolute;left:12px;top:12px;z-index:10;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
  .controls label{color:var(--muted);font-size:13px;margin-right:8px}
  .small{font-size:12px;color:var(--muted)}
  /* Responsive adjustments */
  @media (max-width:900px){
    .side-panel{width:320px;max-width:100%;}
  }
</style>
</head>
<body>
<div class="wrap">
  <div id="visual">
    <div class="controls">
      <label class="small">Planetas carregados:</label> <span id="count" class="small">0</span><br/>
      <label class="small">Vel. animação:</label>
      <input id="speed" type="range" min="0" max="2" step="0.05" value="0.6" />
    </div>

    <canvas id="sky"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>

  <aside id="panel" class="side-panel" aria-hidden="true">
    <button class="closeBtn" id="closePanel" title="Fechar">✕</button>
    <h2 id="pname">—</h2>
    <div class="meta" id="phost">Host star: —</div>
    <div id="pinfo">
      <div class="kv"><div>RA / Dec</div><div id="pra">—</div></div>
      <div class="kv"><div>Distância (pc)</div><div id="pdist">—</div></div>
      <div class="kv"><div>Raio (R⊕)</div><div id="pradius">—</div></div>
      <div class="kv"><div>Período (dias)</div><div id="pperiod">—</div></div>
      <div class="kv"><div>Método descoberta</div><div id="pmethod">—</div></div>
    </div>
    <p style="margin-top:12px;color:var(--muted);font-size:13px">Dados: NASA Exoplanet Archive (Exoplanet table).</p>
  </aside>
</div>

<script>
/*
  Mapa interativo de Exoplanetas — bloco pronto para inserção.
  Fonte da API: https://exoplanetarchive.ipac.caltech.edu/cgi-bin/nstedAPI/nph-nstedAPI?
  (Veja docs oficiais para custom queries). 
  Referências: Exoplanet Archive API docs.
*/

// Configurações
const API_BASE = 'https://exoplanetarchive.ipac.caltech.edu/cgi-bin/nstedAPI/nph-nstedAPI';
const API_QUERY = '?table=exoplanets&select=pl_name,ra,dec,pl_orbsmax,pl_orbper,pl_rade,st_dist,pl_discmethod,hostname&format=json&order=pl_name';
const MAX_POINTS = 3000; // limite para performance (ajuste conforme necessidade)

// Canvas e UI
const canvas = document.getElementById('sky');
const ctx = canvas.getContext('2d', { alpha: true });
const tooltip = document.getElementById('tooltip');
const panel = document.getElementById('panel');
const countEl = document.getElementById('count');
const speedControl = document.getElementById('speed');

let width=0, height=0, dpr=window.devicePixelRatio || 1;
let points = [];
let startTime = performance.now();
let animSpeed = parseFloat(speedControl.value) || 0.6;

// Util: ajustar tamanho
function resize(){ 
  width = canvas.clientWidth;
  height = canvas.clientHeight;
  canvas.width = Math.floor(width * dpr);
  canvas.height = Math.floor(height * dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', resize);
resize();

// Projeção RA/Dec -> x,y (equirectangular)
function project(raDeg, decDeg){
  // RA [0,360), Dec [-90,90]
  const x = (raDeg % 360) / 360 * width;
  const y = (1 - (decDeg + 90) / 180) * height;
  return { x, y };
}

// Pequeno ruído para evitar alinhamento perfeito
function jitter(v, amount=0.6){ return v + (Math.random()*2-1)*amount; }

// Busca dados da NASA Exoplanet Archive
async function fetchExoplanets(){
  try{
    const resp = await fetch(API_BASE + API_QUERY);
    if(!resp.ok) throw new Error('Erro na requisição: ' + resp.status);
    const data = await resp.json();

    // Mapear e filtrar (garantimos RA/Dec)
    const mapped = data
      .filter(d => d.ra !== null && d.dec !== null)
      .slice(0, MAX_POINTS)
      .map((d, i) => {
        const base = project(Number(d.ra), Number(d.dec));
        // radius de desenho baseado na distância ao centro da tela (visual)
        const dx = base.x - width/2, dy = base.y - height/2;
        const distCenter = Math.sqrt(dx*dx + dy*dy);
        // orbitAmplitude: pequena função para movimento
        const orbitAmp = Math.min(18, 2 + distCenter/80 + (d.pl_orbsmax ? Math.log(1+Number(d.pl_orbsmax)) : 0));
        return {
          id: i,
          name: d.pl_name || '—',
          hostname: d.hostname || '—',
          ra: Number(d.ra),
          dec: Number(d.dec),
          orbsmax: d.pl_orbsmax ? Number(d.pl_orbsmax) : null,
          period: d.pl_orbper ? Number(d.pl_orbper) : null,
          radius_re: d.pl_rade ? Number(d.pl_rade) : null,
          dist: d.st_dist ? Number(d.st_dist) : null,
          method: d.pl_discmethod || '—',
          baseX: base.x + (Math.random()*2-1)*1.5,
          baseY: base.y + (Math.random()*2-1)*1.5,
          orbitAmp,
          orbitSpeed: (0.003 + Math.random()*0.02) * (1 + (Math.random()-0.5)),
          phase: Math.random()*Math.PI*2,
          drawSize: 1 + Math.min(3.5, Math.max(0.6, 3.0 - (d.st_dist ? Math.log10(1 + d.st_dist)/2 : 0))))
        ;
      });
    points = mapped;
    countEl.textContent = points.length;
    return mapped;
  } catch(err){
    console.error(err);
    alert('Falha ao carregar dados da NASA Exoplanet Archive. Verifique CORS e conexão.');
    return [];
  }
}

// Desenhar malha suave (linhas finas estilo constelação)
function drawGrid(){
  ctx.save();
  ctx.lineWidth = 0.4;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  const step = Math.max(60, Math.min(140, width/8));
  for(let x=0;x<width;x+=step){
    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke();
  }
  for(let y=0;y<height;y+=step){
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke();
  }
  ctx.restore();
}

// Desenhar linhas de conexão estilo "constelação" (triangulação simples - Delaunay seria ideal, mas evitamos libs)
function drawConnections(){
  ctx.save();
  ctx.lineWidth = 0.6;
  ctx.strokeStyle = 'rgba(255,200,120,0.03)';
  // Strategy: para cada ponto, ligar aos 3 vizinhos mais próximos (O(n^2) mas limitamos por performance)
  const N = points.length;
  for(let i=0;i<N;i++){
    const a = points[i];
    // find few nearest
    const arr = [];
    for(let j=0;j<N;j++){
      if(i===j) continue;
      const b = points[j];
      const dx = a.baseX - b.baseX;
      const dy = a.baseY - b.baseY;
      const d2 = dx*dx + dy*dy;
      arr.push({idx:j,d2});
    }
    arr.sort((p,q)=>p.d2-q.d2);
    const neighbors = arr.slice(0,3);
    neighbors.forEach(n=>{
      const b = points[n.idx];
      ctx.beginPath();
      ctx.moveTo(a.baseX, a.baseY);
      ctx.lineTo(b.baseX, b.baseY);
      ctx.stroke();
    });
  }
  ctx.restore();
}

// Desenhar pontos (com brilho dourado)
function drawPoints(time){
  ctx.save();
  // glow background using radial gradients for some brighter clusters
  points.forEach(p=>{
    // compute animated position
    const t = (time * animSpeed * 0.001) * p.orbitSpeed + p.phase;
    const ax = Math.cos(t) * p.orbitAmp;
    const ay = Math.sin(t) * (p.orbitAmp*0.55);
    const x = p.baseX + ax;
    const y = p.baseY + ay;

    p.screenX = x; p.screenY = y; // store for interactivity

    // subtle trailing star lines
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + (ax*0.17), y + (ay*0.17));
    ctx.strokeStyle = 'rgba(255,200,110,0.06)';
    ctx.lineWidth = 1;
    ctx.stroke();

    // main dot
    const r = p.drawSize;
    // outer glow
    const g = ctx.createRadialGradient(x,y,r*3, x,y, r*0.2);
    g.addColorStop(0, 'rgba(247,201,72,0.16)');
    g.addColorStop(0.5, 'rgba(247,201,72,0.06)');
    g.addColorStop(1, 'rgba(247,201,72,0)');
    ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x,y,r*3.2,0,Math.PI*2); ctx.fill();

    // core
    ctx.beginPath();
    ctx.fillStyle = 'rgba(247,201,72,0.95)';
    ctx.arc(x,y,r,0,Math.PI*2);
    ctx.fill();

    // star cross highlight
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(255,250,220,0.26)';
    ctx.lineWidth = 1;
    ctx.moveTo(x - r*2, y); ctx.lineTo(x + r*2, y);
    ctx.moveTo(x, y - r*2); ctx.lineTo(x, y + r*2);
    ctx.stroke();
  });
  ctx.restore();
}

// Loop principal
function render(now){
  const t = now - startTime;
  ctx.clearRect(0,0,width,height);

  drawGrid();
  drawConnections();
  drawPoints(t);

  requestAnimationFrame(render);
}

// Interatividade
function hitTest(mx,my){
  // search nearest small radius
  for(let i=0;i<points.length;i++){
    const p = points[i];
    const dx = mx - p.screenX;
    const dy = my - p.screenY;
    const d2 = dx*dx + dy*dy;
    const rr = Math.max(6, p.drawSize*4);
    if(d2 < rr*rr) return p;
  }
  return null;
}

let lastHover = null;
canvas.addEventListener('mousemove', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX - rect.left);
  const my = (ev.clientY - rect.top);
  const p = hitTest(mx,my);
  if(p){
    lastHover = p;
    tooltip.style.left = (p.screenX) + 'px';
    tooltip.style.top = (p.screenY) + 'px';
    tooltip.innerHTML = `<strong style="color:var(--gold)">${p.name}</strong><div style="color:rgba(255,255,255,0.78);font-size:12px">Host: ${p.hostname} • dist: ${p.dist? p.dist + ' pc' : '—'}</div>`;
    tooltip.style.display = 'block';
  } else {
    lastHover = null;
    tooltip.style.display = 'none';
  }
});

canvas.addEventListener('click', (ev)=>{
  const rect = canvas.getBoundingClientRect();
  const mx = (ev.clientX - rect.left);
  const my = (ev.clientY - rect.top);
  const p = hitTest(mx,my);
  if(p){
    openPanel(p);
  } else {
    closePanel();
  }
});

// Painel lateral
function openPanel(p){
  document.getElementById('pname').textContent = p.name;
  document.getElementById('phost').textContent = 'Host star: ' + p.hostname;
  document.getElementById('pra').textContent = p.ra.toFixed(3) + ' / ' + p.dec.toFixed(3);
  document.getElementById('pdist').textContent = p.dist ? p.dist + ' pc' : '—';
  document.getElementById('pradius').textContent = p.radius_re ? p.radius_re + ' R⊕' : '—';
  document.getElementById('pperiod').textContent = p.period ? p.period + ' d' : '—';
  document.getElementById('pmethod').textContent = p.method || '—';
  panel.classList.add('open');
  panel.setAttribute('aria-hidden','false');
}
function closePanel(){
  panel.classList.remove('open');
  panel.setAttribute('aria-hidden','true');
}
document.getElementById('closePanel').addEventListener('click', closePanel);

// Controle velocidade
speedControl.addEventListener('input', (e)=>{ animSpeed = Number(e.target.value); });

// Inicializar
(async function init(){
  await fetchExoplanets();
  resize();
  requestAnimationFrame(render);
})();
</script>
</body>
</html>
